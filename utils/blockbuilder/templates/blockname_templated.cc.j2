{% import 'macros.j2' as macros -%}
{{ macros.header() }}
{% set typekeys = properties|selectattr("id", "equalto", "templates")|map(attribute="keys")|first %}
{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
#include <gnuradio/{{module}}/{{block}}.hh>

namespace gr {
namespace {{module}} {

template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
typename {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::sptr {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::make(const block_args& args, available_impl impl)
{
    switch (impl) {
    {% for impl in implementations %}
    #ifdef HAVE_{{ impl['id'] | upper }}
    case available_impl::{{ impl['id'] | upper }}:
        return make_{{ impl['id'] | lower }}(args);
        break;
    #endif
    {% endfor %}
    default:
        throw std::invalid_argument(
            "invalid implementation specified");
    }
}

template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
{{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::{{block}}(const block_args& args) : {{"sync_block" if blocktype == 'sync' else "block"}}("{{ block }}") {
 {{ macros.ports(ports, parameters) }}
}

{%set key1 = typekeys|first %}
{% for opt in key1['options'] -%}
template class {{block}}<{{ opt['value']}}>;
{% endfor -%}

} // namespace {{ module }}
} // namespace gr
