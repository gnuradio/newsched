/*
 * This file is part of GNU Radio
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

/************************************************************/
/* This file is AUTOMATICALLY GENERATED using blockbuilder  */
/*       and should not manually edited                     */
/************************************************************/

#pragma once

{% for incl in includes %}
#include <{{incl['include']}}>
{% endfor %}

{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
{% import 'blocktype.j2' as bl %}
{{ bl.set_block(blocktype) }}
namespace gr {
namespace {{module}} {

class {{ block }} : public {{ 'sync_block' if blocktype == 'sync' else 'block'}}
{
public:
    struct block_args {
        {% import 'parameters.j2' as param %}
        {{ param.set_parameters(parameters) }} };
    
    typedef std::shared_ptr<{{ block }}> sptr;
    {{ block }}(block_args args) : {{"sync_block" if blocktype == 'sync' else "block"}}("{{ block }}")
    {
        {% for port in ports %}
        {% if port['domain'] == 'stream' -%}
        {% if 'multiplicity' not in port%}
        {% from 'add_port.j2' import add_port as add_port %}
        {{ add_port(port, properties) }}
        {% set m = 'args.' + port['multiplicity'] if parameters|selectattr("id", "equalto", port['multiplicity']) else port['multiplicity'] %}
        for (size_t i = 0; i < {{m}}; i++) {
        add_port(untyped_port::make(
            "{{ port['id'] }}" + std::to_string(i), 
            {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}, 
            {{'args.' if properties|selectattr("id", "equalto", port['size'])}}{{ port['size'] }}));
        }
        {% endif -%}
        {% else %}
        {% if port['direction'] == 'input' %}
        _msg_{{port['id']}} = message_port::make(
            "{{port['id']}}", port_direction_t::INPUT);
        _msg_{{port['id']}}->register_callback([this](pmtf::pmt_sptr msg) { this->handle_msg_{{port['id']}}(msg); });
        add_port(_msg_{{port['id']}});
        {% else %}
        _msg_{{port['id']}} = message_port::make(
            "{{port['id']}}", port_direction_t::OUTPUT);
        add_port(_msg_{{port['id']}});
        {% endif %}
        {% endif -%}
        {% endfor %}
    }

    {% import 'implementations_hh.j2' as impl %}
    {{ impl.set_implementations(implementations, callbacks) }}    

    protected:
    {% for port in ports %}{% if port['domain'] == 'message' -%}
        message_port_sptr _msg_{{port['id']}};
    {% endif %}{% endfor %}
    {% for port in ports %}{% if port['domain'] == 'message' and port['direction'] == 'input' -%}
    virtual void handle_msg_{{port['id']}}(pmtf::pmt_sptr msg) = 0;
    {% endif %}{% endfor%}
};

} // namespace {{ module }}
} // namespace gr
