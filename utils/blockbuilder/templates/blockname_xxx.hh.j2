{# first common code: setting block type, type keys, and include statements #}

{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
{% set typekeys = properties|selectattr("id", "equalto", "templates")|map(attribute="keys")|first %}
{%set key1 = typekeys|first %}
{% if blocktype == 'sync' -%}
#include <gnuradio/sync_block.hh>
{% elif blocktype == 'general' -%}
#include <gnuradio/block.hh>
{% endif -%}

{# second common code: seting parameters #}

{% for param in parameters -%}
{{ param['dtype'] }} {{ param['id'] }}{% if 'default' in param %} = {{param['default']}} {% endif %};
{% endfor -%}};

{# third common code: add port function #}

add_port(untyped_port::make(
    "{{ port['id'] }}", 
    {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}, 
    {{'args.' if properties|selectattr("id", "equalto", port['size'])}}{{ port['size'] }}));

{# fourth common code, enum class implementation #}

enum class available_impl { {% for impl in implementations %}{{ impl['id'] | upper }}{{ ", " if not loop.last }}{% endfor %} };
static sptr make(const block_args& args, available_impl impl = available_impl::{{implementations[0]['id'] | upper }});

{# fifth common code, implementations and callbacks #}

{% for impl in implementations %}
/**
* @brief Set the implementation to {{ impl['id'] | upper }} and return a shared pointer to the block instance
* 
* @return std::shared_ptr<{{ block }}> 
*/
static sptr make_{{impl['id']}}(const block_args& args);
{% endfor %}

{% for cb in callbacks -%}
virtual  {{cb['return']}} {{cb['id']}} (
{% if 'args' in cb -%}
{% for arg in cb['args'] -%}
{{arg['dtype']}} {{arg['id']}}{{ ", " if not loop.last }}
{% endfor -%}
{% endif -%}
) {% if cb['const'] %}const {%endif%} = 0;
{% endfor %}

