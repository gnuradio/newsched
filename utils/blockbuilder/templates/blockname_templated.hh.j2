{% import 'macros.j2' as macros -%}
{{ macros.header() }}
#pragma once
{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
{% set typekeys = properties|selectattr("id", "equalto", "templates")|map(attribute="keys")|first %}
{%set key1 = typekeys|first %}
{% if blocktype == 'sync' -%}
#include <gnuradio/sync_block.hh>
{% elif blocktype == 'general' -%}
#include <gnuradio/block.hh>
{% endif -%}
#include <gnuradio/types.hh>

{{ macros.includes(includes) }}

namespace gr {
namespace {{module}} {

template <{% for key in properties|selectattr("id", "equalto", "templates")|map(attribute="keys")|first -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
{{ macros.class_statement(properties, block) }}
{
public:
{{ macros.block_args(parameters) }}
    typedef std::shared_ptr<{{ block }}> sptr;
    {{ macros.cotr_statement(block) }};

    {{ macros.implementations(implementations) }}

    {{ macros.callbacks(callbacks) }}    

    {% for p in parameters -%}
    {% if p['settable']%}
    void set_{{p['id']}}({{p['dtype']}} {{p['id']}});                                             
    {{p['dtype']}} {{p['id']}}();
    {% endif %}
    {% endfor -%}
protected: 

enum params : uint32_t { {% for p in parameters -%}{% if p['settable']%}id_{{p['id']}},{% endif %}{% endfor %} num_params };

{% for p in parameters -%}
{% if p['settable']%}
    typename scalar_param<{{p['dtype']}}>::sptr param_{{p['id']}};
    {% endif %}
    {% endfor -%}

};

{%set key1 = typekeys|first %}
{% for opt in key1['options'] -%}
typedef {{block}}<{{ opt['value']}}> {{block}}_{{ opt['suffix'] }};
{% endfor -%}



} // namespace {{ module }}
} // namespace gr
