#pragma once
{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
{% set typekeys = properties|selectattr("id", "equalto", "templates")|map(attribute="keys")|first %}
{%set key1 = typekeys|first %}
{% import 'blocktype.j2' as bl %}
{{ bl.set_block(blocktype) }}

#include <gnuradio/types.hh>

namespace gr {
namespace {{module}} {

template <{% for key in properties|selectattr("id", "equalto", "templates")|map(attribute="keys")|first -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
class {{ block }} : public {{ 'sync_block' if blocktype == 'sync' else 'block'}}
{
public:
    struct block_args {
        {% import 'parameters.j2' as param %}
        {{ param.set_parameters(parameters) }} };
    typedef std::shared_ptr<{{ block }}> sptr;
    {{ block }}(block_args args) : sync_block("{{ block }}")
    {
        {% for port in ports %}
        {% if port['type'] == 'untyped' %}
        {% from 'add_port.j2' import add_port as add_port %}
        {{ add_port(port, properties) }}
        add_port(port<{{key1['id']}}>::make("{{ port['id'] }}", 
                                    {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}, 
                                    std::vector<size_t>{{ port['dims'] }}));
        {% endif %}
        {% endfor %}
    }

    {% import 'implementations_hh.j2' as impl %}
    {{ impl.set_implementations(implementations, callbacks) }}
 
};

{%set key1 = typekeys|first %}
{% for opt in key1['options'] -%}
typedef {{block}}<{{ opt['value']}}> {{block}}_{{ opt['suffix'] }};
{% endfor -%}


} // namespace {{ module }}
} // namespace gr
