{% macro header() -%}
/*
 * This file is part of GNU Radio
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

/************************************************************/
/* This file is AUTOMATICALLY GENERATED using blockbuilder  */
/*       and should not manually edited                     */
/************************************************************/
{% endmacro %}

{% macro includes(includes) -%}
{% for incl in includes %}
#include <{{incl['value']}}>
{% endfor %}
{% endmacro %}

{% macro blocktype(properties) -%}
{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
{% if blocktype == 'sync' -%}
#include <gnuradio/sync_block.hh>
{% elif blocktype == 'general' -%}
#include <gnuradio/block.hh>
{% endif -%}
{% endmacro %}

{% macro class_statement(properties, block) -%}
{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
class {{ block }} : virtual public {{ 'sync_block' if blocktype == 'sync' else 'block'}}
{% endmacro %}

{% macro block_args(parameters) -%}
    struct block_args {
        {% if parameters %} {% for param in parameters -%}
        {{ param['dtype'] }} {{ param['id'] }}{% if 'default' in param %} = {{param['default']}}{% endif %};
        {% endfor -%}{% endif %}};
{% endmacro %}

{% macro cotr_statement(block) -%}
{{ block }}(const block_args& args);
{% endmacro %}


{% macro ports(ports, parameters) -%}
        {% for port in ports %}
        {% if port['domain'] == 'stream' -%}
        {% if 'multiplicity' not in port%}     
        {% if port['type'] == 'untyped'%}                                  
        add_port(untyped_port::make(
            "{{ port['id'] }}", 
            {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}, 
            {{ 'args.' if parameters|selectattr("id", "equalto", port['size'])|first }}{{ port['size'] }}));
        {% else %}
        add_port(port<{{port['type']}}>::make("{{ port['id'] }}", 
                            {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}
                            {% if 'dims' in port %}, std::vector<size_t>{{ port['dims'] }} {% endif %}));
        {% endif %}
        {% else %}
        {% set m = 'args.' + port['multiplicity'] if parameters|selectattr("id", "equalto", port['multiplicity']) else port['multiplicity'] %}
        {% if port['type'] == 'untyped'%}   
        for (size_t i = 0; i < {{m}}; i++) {
        add_port(untyped_port::make(
            "{{ port['id'] }}" + std::to_string(i), 
            {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}, 
            {{'args.' if parameters|selectattr("id", "equalto", port['size'])|first }}{{ port['size'] }}));
        }
        {% else %}
        for (size_t i = 0; i < {{m}}; i++) {
        add_port(port<{{port['type']}}>::make("{{ port['id'] }}" + std::to_string(i), 
                            {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}
                            {% if 'dims' in port %}, std::vector<size_t>{{ port['dims'] }} {% endif %}));
        }
        {% endif %}
        {% endif -%}
        {% else %}
        {% if port['direction'] == 'input' %}
        _msg_{{port['id']}} = message_port::make(
            "{{port['id']}}", port_direction_t::INPUT);
        _msg_{{port['id']}}->register_callback([this](pmt::pmt_t msg) { this->handle_msg_{{port['id']}}(msg); });
        add_port(_msg_{{port['id']}});
        {% else %}
        _msg_{{port['id']}} = message_port::make(
            "{{port['id']}}", port_direction_t::OUTPUT);
        add_port(_msg_{{port['id']}});
        {% endif %}
        {% endif -%}
        {% endfor %}
{% endmacro %}

{% macro implementations(implementations) -%}
    enum class available_impl { {% for impl in implementations %}{{ impl['id'] | upper }}{{ ", " if not loop.last }}{% endfor %} };
    static sptr make(const block_args& args, available_impl impl = available_impl::{{implementations[0]['id'] | upper }});

    {% for impl in implementations %}
    /**
     * @brief Set the implementation to {{ impl['id'] | upper }} and return a shared pointer to the block instance
     * 
     * @return std::shared_ptr<{{ block }}> 
     */
    static sptr make_{{impl['id']}}(const block_args& args);
    {% endfor %}
{% endmacro %}

{% macro callbacks(callbacks) -%}
    {% for cb in callbacks -%}
    virtual  {{cb['return']}} {{cb['id']}} (
    {% if 'args' in cb -%}
    {% for arg in cb['args'] -%}
    {{arg['dtype']}} {{arg['id']}}{{ ", " if not loop.last }}
    {% endfor -%}
    {% endif -%}
    ) {% if cb['const'] %}const {%endif%} = 0;
    {% endfor %} 
{% endmacro %}

{% macro message_ports(ports) -%}
    {% for port in ports %}{% if port['domain'] == 'message' -%}
        message_port_sptr _msg_{{port['id']}};
    {% endif %}{% endfor %}
    {% for port in ports %}{% if port['domain'] == 'message' and port['direction'] == 'input' -%}
    virtual void handle_msg_{{port['id']}}(pmt::pmt_t msg) = 0;
    {% endif %}{% endfor%}
{% endmacro %}