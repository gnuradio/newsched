#pragma once

#include <gnuradio/domain_adapter.hpp>

namespace gr {

/**
 * @brief Uses a simple zmq socket to communicate buffer pointers between domains
 *
 */
class domain_adapter_zmq_rep_svr : public domain_adapter
{
private:
    zmq::context_t* d_context;
    zmq::socket_t* d_socket;

    bool d_connected = false;
    std::thread d_thread;

public:
    typedef std::shared_ptr<domain_adapter_zmq_rep_svr> sptr;
    static sptr make(const std::string& endpoint_uri, port_sptr other_port)
    {
        auto ptr = std::make_shared<domain_adapter_zmq_rep_svr>(
            endpoint_uri);

        ptr->add_port(port_base::make("output",
                                      port_direction_t::OUTPUT,
                                      other_port->data_type(),
                                      port_type_t::STREAM,
                                      other_port->dims()));

        ptr->start_thread(ptr); // start thread with reference to shared pointer

        return ptr;
    }

    domain_adapter_zmq_rep_svr(const std::string& endpoint_uri);

    void start_thread(sptr ptr);

    static void run_thread(sptr top);

    virtual void* read_ptr() { return nullptr; }
    virtual void* write_ptr() { return nullptr; }

    // virtual int capacity() = 0;
    // virtual int size() = 0;

    virtual bool read_info(buffer_info_t& info) { return _buffer->read_info(info); }
    virtual bool write_info(buffer_info_t& info)
    {
        // If I am the server, I am the buffer host
        return _buffer->write_info(info);
        // should not get called
        // throw std::runtime_error("write_info not valid for da_svr block"); // TODO
        // logging buffer_info_t ret; return ret;
    }
    virtual void cancel() { _buffer->cancel(); }

    virtual void post_read(int num_items) { return _buffer->post_read(num_items); }
    virtual void post_write(int num_items) { return _buffer->post_write(num_items); }

    // This is not valid for all buffers, e.g. domain adapters
    virtual void copy_items(buffer_sptr from, int nitems) {}
};


class domain_adapter_zmq_req_cli : public domain_adapter
{
    zmq::context_t* d_context;
    zmq::socket_t* d_socket;

public:
    typedef std::shared_ptr<domain_adapter_zmq_req_cli> sptr;
    static sptr make(const std::string& endpoint_uri, port_sptr other_port)
    {
        auto ptr = std::make_shared<domain_adapter_zmq_req_cli>(
            endpoint_uri);

        // Type of port is not known at compile time
        ptr->add_port(port_base::make("input",
                                      port_direction_t::INPUT,
                                      other_port->data_type(),
                                      port_type_t::STREAM,
                                      other_port->dims()));

        return ptr;
    }
    domain_adapter_zmq_req_cli(const std::string& endpoint_uri);

    virtual void* read_ptr() { return nullptr; }
    virtual void* write_ptr() { return nullptr; }

    // virtual int capacity() = 0;
    // virtual int size() = 0;

    virtual bool read_info(buffer_info_t& info);
    virtual bool write_info(buffer_info_t& info);
    virtual void cancel();

    virtual void post_read(int num_items);
    virtual void post_write(int num_items);

    // This is not valid for all buffers, e.g. domain adapters
    // Currently domain adapters require fanout, and cannot copy from a shared output
    // across multiple domains
    virtual void copy_items(buffer_sptr from, int nitems) {}
};

/**
 * @brief Domain Adapter configuration for specified endpoint pair
 *
 * Allows a domain adapter pair to be generated by specifying a pair of endpoints
 */
class domain_adapter_zmq_conf : public domain_adapter_conf
{
public:
    typedef std::shared_ptr<domain_adapter_zmq_conf> sptr;
    static sptr make(buffer_preference_t buf_pref,
                     const std::string& endpoint_upstream,
                     const std::string& endpoint_downstream)
    {
        return std::make_shared<domain_adapter_zmq_conf>(
            buf_pref, endpoint_upstream, endpoint_downstream);
    }

    domain_adapter_zmq_conf(buffer_preference_t buf_pref,
                            const std::string& endpoint_upstream,
                            const std::string& endpoint_downstream)
        : domain_adapter_conf(buf_pref),
          _endpoint_upstream(endpoint_upstream),
          _endpoint_downstream(endpoint_downstream)
    {
    }

    virtual std::pair<domain_adapter_sptr, domain_adapter_sptr>
    make_domain_adapter_pair(port_sptr upstream_port, port_sptr downstream_port, const std::string& name="")
    {

        if (_buf_pref == buffer_preference_t::DOWNSTREAM) {
            auto upstream_adapter =
                domain_adapter_zmq_req_cli::make(_endpoint_upstream, upstream_port);
            auto downstream_adapter =
                domain_adapter_zmq_rep_svr::make(_endpoint_downstream, downstream_port);
            return std::make_pair(upstream_adapter, downstream_adapter);
        } else {
            auto downstream_adapter =
                domain_adapter_zmq_req_cli::make(_endpoint_downstream, downstream_port);
            auto upstream_adapter =
                domain_adapter_zmq_rep_svr::make(_endpoint_upstream, upstream_port);
            return std::make_pair(upstream_adapter, downstream_adapter);
        }
    }

private:
    std::string _endpoint_upstream = "";
    std::string _endpoint_downstream = "";
};

// typedef std::map<edge, domain_adapter_conf> domain_adapter_conf_per_edge;

// Default Domain Adapter configuration should be derived from some sort of preferences
// file
// TODO: preferences

class domain_adapter_zmq_tcp_conf : public domain_adapter_conf
{
public:
    typedef std::shared_ptr<domain_adapter_zmq_tcp_conf> sptr;
    static sptr make(std::vector<int> ports,
                     std::string ip_address = "127.0.0.1",
                     buffer_preference_t buf_pref = buffer_preference_t::DOWNSTREAM)
    {
        return std::make_shared<domain_adapter_zmq_tcp_conf>(
            ports, ip_address, buf_pref);
    }

    domain_adapter_zmq_tcp_conf(std::vector<int> ports,
                                std::string ip_address,
                                buffer_preference_t buf_pref)
        : domain_adapter_conf(buf_pref), _available_ports(ports), _ip_address(ip_address)
    {
    }

    virtual std::pair<domain_adapter_sptr, domain_adapter_sptr>
    make_domain_adapter_pair(port_sptr upstream_port, port_sptr downstream_port, const std::string& name="")
    {
        // TODO: check whether port is available
        auto port = _available_ports[0];
        _available_ports.erase(_available_ports.begin());

        std::string endpoint_upstream =
            "tcp://" + _ip_address + ":" + std::to_string(port);
        std::string endpoint_downstream =
            "tcp://" + _ip_address + ":" + std::to_string(port);
        if (_buf_pref == buffer_preference_t::DOWNSTREAM) {
            auto upstream_adapter =
                domain_adapter_zmq_req_cli::make(endpoint_upstream, upstream_port);
            auto downstream_adapter =
                domain_adapter_zmq_rep_svr::make(endpoint_downstream, downstream_port);

            return std::make_pair(upstream_adapter, downstream_adapter);
        } else {
            auto downstream_adapter =
                domain_adapter_zmq_req_cli::make(endpoint_downstream, upstream_port);
            auto upstream_adapter =
                domain_adapter_zmq_rep_svr::make(endpoint_upstream, downstream_port);

            return std::make_pair(upstream_adapter, downstream_adapter);
        }
    }

private:
    std::vector<int> _available_ports;
    std::string _ip_address;
    std::string _endpoint_upstream = "";
    std::string _endpoint_downstream = "";
};


} // namespace gr
