// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PMT_PMTF_H_
#define FLATBUFFERS_GENERATED_PMT_PMTF_H_

#include "flatbuffers/flatbuffers.h"

namespace pmtf {

struct Complex64;

struct Complex128;

struct PmtString;
struct PmtStringBuilder;

struct ScalarFloat32;
struct ScalarFloat32Builder;

struct ScalarFloat64;
struct ScalarFloat64Builder;

struct ScalarComplex64;
struct ScalarComplex64Builder;

struct ScalarComplex128;
struct ScalarComplex128Builder;

struct ScalarInt8;
struct ScalarInt8Builder;

struct ScalarInt16;
struct ScalarInt16Builder;

struct ScalarInt32;
struct ScalarInt32Builder;

struct ScalarInt64;
struct ScalarInt64Builder;

struct ScalarUInt8;
struct ScalarUInt8Builder;

struct ScalarUInt16;
struct ScalarUInt16Builder;

struct ScalarUInt32;
struct ScalarUInt32Builder;

struct ScalarUInt64;
struct ScalarUInt64Builder;

struct ScalarBool;
struct ScalarBoolBuilder;

struct VectorFloat32;
struct VectorFloat32Builder;

struct VectorFloat64;
struct VectorFloat64Builder;

struct VectorComplex64;
struct VectorComplex64Builder;

struct VectorComplex128;
struct VectorComplex128Builder;

struct VectorInt8;
struct VectorInt8Builder;

struct VectorInt16;
struct VectorInt16Builder;

struct VectorInt32;
struct VectorInt32Builder;

struct VectorInt64;
struct VectorInt64Builder;

struct VectorUInt8;
struct VectorUInt8Builder;

struct VectorUInt16;
struct VectorUInt16Builder;

struct VectorUInt32;
struct VectorUInt32Builder;

struct VectorUInt64;
struct VectorUInt64Builder;

struct VectorBool;
struct VectorBoolBuilder;

struct VectorPmt;
struct VectorPmtBuilder;

struct MapEntryString;
struct MapEntryStringBuilder;

struct MapString;
struct MapStringBuilder;

struct Pmt;
struct PmtBuilder;

inline const flatbuffers::TypeTable *Complex64TypeTable();

inline const flatbuffers::TypeTable *Complex128TypeTable();

inline const flatbuffers::TypeTable *PmtStringTypeTable();

inline const flatbuffers::TypeTable *ScalarFloat32TypeTable();

inline const flatbuffers::TypeTable *ScalarFloat64TypeTable();

inline const flatbuffers::TypeTable *ScalarComplex64TypeTable();

inline const flatbuffers::TypeTable *ScalarComplex128TypeTable();

inline const flatbuffers::TypeTable *ScalarInt8TypeTable();

inline const flatbuffers::TypeTable *ScalarInt16TypeTable();

inline const flatbuffers::TypeTable *ScalarInt32TypeTable();

inline const flatbuffers::TypeTable *ScalarInt64TypeTable();

inline const flatbuffers::TypeTable *ScalarUInt8TypeTable();

inline const flatbuffers::TypeTable *ScalarUInt16TypeTable();

inline const flatbuffers::TypeTable *ScalarUInt32TypeTable();

inline const flatbuffers::TypeTable *ScalarUInt64TypeTable();

inline const flatbuffers::TypeTable *ScalarBoolTypeTable();

inline const flatbuffers::TypeTable *VectorFloat32TypeTable();

inline const flatbuffers::TypeTable *VectorFloat64TypeTable();

inline const flatbuffers::TypeTable *VectorComplex64TypeTable();

inline const flatbuffers::TypeTable *VectorComplex128TypeTable();

inline const flatbuffers::TypeTable *VectorInt8TypeTable();

inline const flatbuffers::TypeTable *VectorInt16TypeTable();

inline const flatbuffers::TypeTable *VectorInt32TypeTable();

inline const flatbuffers::TypeTable *VectorInt64TypeTable();

inline const flatbuffers::TypeTable *VectorUInt8TypeTable();

inline const flatbuffers::TypeTable *VectorUInt16TypeTable();

inline const flatbuffers::TypeTable *VectorUInt32TypeTable();

inline const flatbuffers::TypeTable *VectorUInt64TypeTable();

inline const flatbuffers::TypeTable *VectorBoolTypeTable();

inline const flatbuffers::TypeTable *VectorPmtTypeTable();

inline const flatbuffers::TypeTable *MapEntryStringTypeTable();

inline const flatbuffers::TypeTable *MapStringTypeTable();

inline const flatbuffers::TypeTable *PmtTypeTable();

enum class DataType : int8_t {
  UNKNOWN = 0,
  FLOAT = 1,
  DOUBLE = 2,
  CFLOAT = 3,
  CDOUBLE = 4,
  INT8 = 5,
  INT16 = 6,
  INT32 = 7,
  INT64 = 8,
  UINT8 = 9,
  UINT16 = 10,
  UINT32 = 11,
  UINT64 = 12,
  BOOL = 13,
  ENUM = 14,
  STRING = 15,
  PMT = 16,
  ANY = 17,
  VOID = 18,
  MIN = UNKNOWN,
  MAX = VOID
};

inline const DataType (&EnumValuesDataType())[19] {
  static const DataType values[] = {
    DataType::UNKNOWN,
    DataType::FLOAT,
    DataType::DOUBLE,
    DataType::CFLOAT,
    DataType::CDOUBLE,
    DataType::INT8,
    DataType::INT16,
    DataType::INT32,
    DataType::INT64,
    DataType::UINT8,
    DataType::UINT16,
    DataType::UINT32,
    DataType::UINT64,
    DataType::BOOL,
    DataType::ENUM,
    DataType::STRING,
    DataType::PMT,
    DataType::ANY,
    DataType::VOID
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[20] = {
    "UNKNOWN",
    "FLOAT",
    "DOUBLE",
    "CFLOAT",
    "CDOUBLE",
    "INT8",
    "INT16",
    "INT32",
    "INT64",
    "UINT8",
    "UINT16",
    "UINT32",
    "UINT64",
    "BOOL",
    "ENUM",
    "STRING",
    "PMT",
    "ANY",
    "VOID",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType::UNKNOWN, DataType::VOID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class Data : uint8_t {
  NONE = 0,
  PmtString = 1,
  ScalarFloat32 = 2,
  ScalarFloat64 = 3,
  ScalarComplex64 = 4,
  ScalarComplex128 = 5,
  ScalarInt8 = 6,
  ScalarInt16 = 7,
  ScalarInt32 = 8,
  ScalarInt64 = 9,
  ScalarUInt8 = 10,
  ScalarUInt16 = 11,
  ScalarUInt32 = 12,
  ScalarUInt64 = 13,
  ScalarBool = 14,
  VectorFloat32 = 15,
  VectorFloat64 = 16,
  VectorComplex64 = 17,
  VectorComplex128 = 18,
  VectorInt8 = 19,
  VectorInt16 = 20,
  VectorInt32 = 21,
  VectorInt64 = 22,
  VectorUInt8 = 23,
  VectorUInt16 = 24,
  VectorUInt32 = 25,
  VectorUInt64 = 26,
  VectorBool = 27,
  VectorPmt = 28,
  MapString = 29,
  MIN = NONE,
  MAX = MapString
};

inline const Data (&EnumValuesData())[30] {
  static const Data values[] = {
    Data::NONE,
    Data::PmtString,
    Data::ScalarFloat32,
    Data::ScalarFloat64,
    Data::ScalarComplex64,
    Data::ScalarComplex128,
    Data::ScalarInt8,
    Data::ScalarInt16,
    Data::ScalarInt32,
    Data::ScalarInt64,
    Data::ScalarUInt8,
    Data::ScalarUInt16,
    Data::ScalarUInt32,
    Data::ScalarUInt64,
    Data::ScalarBool,
    Data::VectorFloat32,
    Data::VectorFloat64,
    Data::VectorComplex64,
    Data::VectorComplex128,
    Data::VectorInt8,
    Data::VectorInt16,
    Data::VectorInt32,
    Data::VectorInt64,
    Data::VectorUInt8,
    Data::VectorUInt16,
    Data::VectorUInt32,
    Data::VectorUInt64,
    Data::VectorBool,
    Data::VectorPmt,
    Data::MapString
  };
  return values;
}

inline const char * const *EnumNamesData() {
  static const char * const names[31] = {
    "NONE",
    "PmtString",
    "ScalarFloat32",
    "ScalarFloat64",
    "ScalarComplex64",
    "ScalarComplex128",
    "ScalarInt8",
    "ScalarInt16",
    "ScalarInt32",
    "ScalarInt64",
    "ScalarUInt8",
    "ScalarUInt16",
    "ScalarUInt32",
    "ScalarUInt64",
    "ScalarBool",
    "VectorFloat32",
    "VectorFloat64",
    "VectorComplex64",
    "VectorComplex128",
    "VectorInt8",
    "VectorInt16",
    "VectorInt32",
    "VectorInt64",
    "VectorUInt8",
    "VectorUInt16",
    "VectorUInt32",
    "VectorUInt64",
    "VectorBool",
    "VectorPmt",
    "MapString",
    nullptr
  };
  return names;
}

inline const char *EnumNameData(Data e) {
  if (flatbuffers::IsOutRange(e, Data::NONE, Data::MapString)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesData()[index];
}

template<typename T> struct DataTraits {
  static const Data enum_value = Data::NONE;
};

template<> struct DataTraits<pmtf::PmtString> {
  static const Data enum_value = Data::PmtString;
};

template<> struct DataTraits<pmtf::ScalarFloat32> {
  static const Data enum_value = Data::ScalarFloat32;
};

template<> struct DataTraits<pmtf::ScalarFloat64> {
  static const Data enum_value = Data::ScalarFloat64;
};

template<> struct DataTraits<pmtf::ScalarComplex64> {
  static const Data enum_value = Data::ScalarComplex64;
};

template<> struct DataTraits<pmtf::ScalarComplex128> {
  static const Data enum_value = Data::ScalarComplex128;
};

template<> struct DataTraits<pmtf::ScalarInt8> {
  static const Data enum_value = Data::ScalarInt8;
};

template<> struct DataTraits<pmtf::ScalarInt16> {
  static const Data enum_value = Data::ScalarInt16;
};

template<> struct DataTraits<pmtf::ScalarInt32> {
  static const Data enum_value = Data::ScalarInt32;
};

template<> struct DataTraits<pmtf::ScalarInt64> {
  static const Data enum_value = Data::ScalarInt64;
};

template<> struct DataTraits<pmtf::ScalarUInt8> {
  static const Data enum_value = Data::ScalarUInt8;
};

template<> struct DataTraits<pmtf::ScalarUInt16> {
  static const Data enum_value = Data::ScalarUInt16;
};

template<> struct DataTraits<pmtf::ScalarUInt32> {
  static const Data enum_value = Data::ScalarUInt32;
};

template<> struct DataTraits<pmtf::ScalarUInt64> {
  static const Data enum_value = Data::ScalarUInt64;
};

template<> struct DataTraits<pmtf::ScalarBool> {
  static const Data enum_value = Data::ScalarBool;
};

template<> struct DataTraits<pmtf::VectorFloat32> {
  static const Data enum_value = Data::VectorFloat32;
};

template<> struct DataTraits<pmtf::VectorFloat64> {
  static const Data enum_value = Data::VectorFloat64;
};

template<> struct DataTraits<pmtf::VectorComplex64> {
  static const Data enum_value = Data::VectorComplex64;
};

template<> struct DataTraits<pmtf::VectorComplex128> {
  static const Data enum_value = Data::VectorComplex128;
};

template<> struct DataTraits<pmtf::VectorInt8> {
  static const Data enum_value = Data::VectorInt8;
};

template<> struct DataTraits<pmtf::VectorInt16> {
  static const Data enum_value = Data::VectorInt16;
};

template<> struct DataTraits<pmtf::VectorInt32> {
  static const Data enum_value = Data::VectorInt32;
};

template<> struct DataTraits<pmtf::VectorInt64> {
  static const Data enum_value = Data::VectorInt64;
};

template<> struct DataTraits<pmtf::VectorUInt8> {
  static const Data enum_value = Data::VectorUInt8;
};

template<> struct DataTraits<pmtf::VectorUInt16> {
  static const Data enum_value = Data::VectorUInt16;
};

template<> struct DataTraits<pmtf::VectorUInt32> {
  static const Data enum_value = Data::VectorUInt32;
};

template<> struct DataTraits<pmtf::VectorUInt64> {
  static const Data enum_value = Data::VectorUInt64;
};

template<> struct DataTraits<pmtf::VectorBool> {
  static const Data enum_value = Data::VectorBool;
};

template<> struct DataTraits<pmtf::VectorPmt> {
  static const Data enum_value = Data::VectorPmt;
};

template<> struct DataTraits<pmtf::MapString> {
  static const Data enum_value = Data::MapString;
};

bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type);
bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Complex64 FLATBUFFERS_FINAL_CLASS {
 private:
  float re_;
  float im_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Complex64TypeTable();
  }
  Complex64()
      : re_(0),
        im_(0) {
  }
  Complex64(float _re, float _im)
      : re_(flatbuffers::EndianScalar(_re)),
        im_(flatbuffers::EndianScalar(_im)) {
  }
  float re() const {
    return flatbuffers::EndianScalar(re_);
  }
  void mutate_re(float _re) {
    flatbuffers::WriteScalar(&re_, _re);
  }
  float im() const {
    return flatbuffers::EndianScalar(im_);
  }
  void mutate_im(float _im) {
    flatbuffers::WriteScalar(&im_, _im);
  }
};
FLATBUFFERS_STRUCT_END(Complex64, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Complex128 FLATBUFFERS_FINAL_CLASS {
 private:
  double re_;
  double im_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Complex128TypeTable();
  }
  Complex128()
      : re_(0),
        im_(0) {
  }
  Complex128(double _re, double _im)
      : re_(flatbuffers::EndianScalar(_re)),
        im_(flatbuffers::EndianScalar(_im)) {
  }
  double re() const {
    return flatbuffers::EndianScalar(re_);
  }
  void mutate_re(double _re) {
    flatbuffers::WriteScalar(&re_, _re);
  }
  double im() const {
    return flatbuffers::EndianScalar(im_);
  }
  void mutate_im(double _im) {
    flatbuffers::WriteScalar(&im_, _im);
  }
};
FLATBUFFERS_STRUCT_END(Complex128, 16);

struct PmtString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PmtStringBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PmtStringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  flatbuffers::String *mutable_value() {
    return GetPointer<flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct PmtStringBuilder {
  typedef PmtString Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(PmtString::VT_VALUE, value);
  }
  explicit PmtStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PmtString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PmtString>(end);
    return o;
  }
};

inline flatbuffers::Offset<PmtString> CreatePmtString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  PmtStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct PmtString::Traits {
  using type = PmtString;
  static auto constexpr Create = CreatePmtString;
};

inline flatbuffers::Offset<PmtString> CreatePmtStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return pmtf::CreatePmtString(
      _fbb,
      value__);
}

struct ScalarFloat32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarFloat32Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarFloat32TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool mutate_value(float _value) {
    return SetField<float>(VT_VALUE, _value, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarFloat32Builder {
  typedef ScalarFloat32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(ScalarFloat32::VT_VALUE, value, 0.0f);
  }
  explicit ScalarFloat32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarFloat32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarFloat32>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarFloat32> CreateScalarFloat32(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  ScalarFloat32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarFloat32::Traits {
  using type = ScalarFloat32;
  static auto constexpr Create = CreateScalarFloat32;
};

struct ScalarFloat64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarFloat64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarFloat64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool mutate_value(double _value) {
    return SetField<double>(VT_VALUE, _value, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarFloat64Builder {
  typedef ScalarFloat64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(ScalarFloat64::VT_VALUE, value, 0.0);
  }
  explicit ScalarFloat64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarFloat64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarFloat64>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarFloat64> CreateScalarFloat64(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  ScalarFloat64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarFloat64::Traits {
  using type = ScalarFloat64;
  static auto constexpr Create = CreateScalarFloat64;
};

struct ScalarComplex64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarComplex64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarComplex64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const pmtf::Complex64 *value() const {
    return GetStruct<const pmtf::Complex64 *>(VT_VALUE);
  }
  pmtf::Complex64 *mutable_value() {
    return GetStruct<pmtf::Complex64 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<pmtf::Complex64>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarComplex64Builder {
  typedef ScalarComplex64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const pmtf::Complex64 *value) {
    fbb_.AddStruct(ScalarComplex64::VT_VALUE, value);
  }
  explicit ScalarComplex64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarComplex64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarComplex64>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarComplex64> CreateScalarComplex64(
    flatbuffers::FlatBufferBuilder &_fbb,
    const pmtf::Complex64 *value = 0) {
  ScalarComplex64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarComplex64::Traits {
  using type = ScalarComplex64;
  static auto constexpr Create = CreateScalarComplex64;
};

struct ScalarComplex128 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarComplex128Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarComplex128TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const pmtf::Complex128 *value() const {
    return GetStruct<const pmtf::Complex128 *>(VT_VALUE);
  }
  pmtf::Complex128 *mutable_value() {
    return GetStruct<pmtf::Complex128 *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<pmtf::Complex128>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarComplex128Builder {
  typedef ScalarComplex128 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const pmtf::Complex128 *value) {
    fbb_.AddStruct(ScalarComplex128::VT_VALUE, value);
  }
  explicit ScalarComplex128Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarComplex128> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarComplex128>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarComplex128> CreateScalarComplex128(
    flatbuffers::FlatBufferBuilder &_fbb,
    const pmtf::Complex128 *value = 0) {
  ScalarComplex128Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarComplex128::Traits {
  using type = ScalarComplex128;
  static auto constexpr Create = CreateScalarComplex128;
};

struct ScalarInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarInt8Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarInt8TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool mutate_value(int8_t _value) {
    return SetField<int8_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarInt8Builder {
  typedef ScalarInt8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(ScalarInt8::VT_VALUE, value, 0);
  }
  explicit ScalarInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarInt8> CreateScalarInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  ScalarInt8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarInt8::Traits {
  using type = ScalarInt8;
  static auto constexpr Create = CreateScalarInt8;
};

struct ScalarInt16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarInt16Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarInt16TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool mutate_value(int16_t _value) {
    return SetField<int16_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarInt16Builder {
  typedef ScalarInt16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(ScalarInt16::VT_VALUE, value, 0);
  }
  explicit ScalarInt16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarInt16>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarInt16> CreateScalarInt16(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  ScalarInt16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarInt16::Traits {
  using type = ScalarInt16;
  static auto constexpr Create = CreateScalarInt16;
};

struct ScalarInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarInt32Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarInt32TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool mutate_value(int32_t _value) {
    return SetField<int32_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarInt32Builder {
  typedef ScalarInt32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(ScalarInt32::VT_VALUE, value, 0);
  }
  explicit ScalarInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarInt32> CreateScalarInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  ScalarInt32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarInt32::Traits {
  using type = ScalarInt32;
  static auto constexpr Create = CreateScalarInt32;
};

struct ScalarInt64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarInt64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarInt64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool mutate_value(int64_t _value) {
    return SetField<int64_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarInt64Builder {
  typedef ScalarInt64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(ScalarInt64::VT_VALUE, value, 0);
  }
  explicit ScalarInt64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarInt64>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarInt64> CreateScalarInt64(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  ScalarInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarInt64::Traits {
  using type = ScalarInt64;
  static auto constexpr Create = CreateScalarInt64;
};

struct ScalarUInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarUInt8Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarUInt8TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint8_t _value) {
    return SetField<uint8_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarUInt8Builder {
  typedef ScalarUInt8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(ScalarUInt8::VT_VALUE, value, 0);
  }
  explicit ScalarUInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarUInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarUInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarUInt8> CreateScalarUInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  ScalarUInt8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarUInt8::Traits {
  using type = ScalarUInt8;
  static auto constexpr Create = CreateScalarUInt8;
};

struct ScalarUInt16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarUInt16Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarUInt16TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint16_t _value) {
    return SetField<uint16_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarUInt16Builder {
  typedef ScalarUInt16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(ScalarUInt16::VT_VALUE, value, 0);
  }
  explicit ScalarUInt16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarUInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarUInt16>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarUInt16> CreateScalarUInt16(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  ScalarUInt16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarUInt16::Traits {
  using type = ScalarUInt16;
  static auto constexpr Create = CreateScalarUInt16;
};

struct ScalarUInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarUInt32Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarUInt32TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint32_t _value) {
    return SetField<uint32_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarUInt32Builder {
  typedef ScalarUInt32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(ScalarUInt32::VT_VALUE, value, 0);
  }
  explicit ScalarUInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarUInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarUInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarUInt32> CreateScalarUInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  ScalarUInt32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarUInt32::Traits {
  using type = ScalarUInt32;
  static auto constexpr Create = CreateScalarUInt32;
};

struct ScalarUInt64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarUInt64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarUInt64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint64_t _value) {
    return SetField<uint64_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarUInt64Builder {
  typedef ScalarUInt64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(ScalarUInt64::VT_VALUE, value, 0);
  }
  explicit ScalarUInt64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarUInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarUInt64>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarUInt64> CreateScalarUInt64(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  ScalarUInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarUInt64::Traits {
  using type = ScalarUInt64;
  static auto constexpr Create = CreateScalarUInt64;
};

struct ScalarBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarBoolBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScalarBoolTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool mutate_value(bool _value) {
    return SetField<uint8_t>(VT_VALUE, static_cast<uint8_t>(_value), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ScalarBoolBuilder {
  typedef ScalarBool Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(ScalarBool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit ScalarBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarBool> CreateScalarBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  ScalarBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ScalarBool::Traits {
  using type = ScalarBool;
  static auto constexpr Create = CreateScalarBool;
};

struct VectorFloat32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorFloat32Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorFloat32TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  flatbuffers::Vector<float> *mutable_value() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorFloat32Builder {
  typedef VectorFloat32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(VectorFloat32::VT_VALUE, value);
  }
  explicit VectorFloat32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorFloat32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorFloat32>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorFloat32> CreateVectorFloat32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  VectorFloat32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorFloat32::Traits {
  using type = VectorFloat32;
  static auto constexpr Create = CreateVectorFloat32;
};

inline flatbuffers::Offset<VectorFloat32> CreateVectorFloat32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return pmtf::CreateVectorFloat32(
      _fbb,
      value__);
}

struct VectorFloat64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorFloat64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorFloat64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<double> *value() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUE);
  }
  flatbuffers::Vector<double> *mutable_value() {
    return GetPointer<flatbuffers::Vector<double> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorFloat64Builder {
  typedef VectorFloat64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<double>> value) {
    fbb_.AddOffset(VectorFloat64::VT_VALUE, value);
  }
  explicit VectorFloat64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorFloat64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorFloat64>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorFloat64> CreateVectorFloat64(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> value = 0) {
  VectorFloat64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorFloat64::Traits {
  using type = VectorFloat64;
  static auto constexpr Create = CreateVectorFloat64;
};

inline flatbuffers::Offset<VectorFloat64> CreateVectorFloat64Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<double>(*value) : 0;
  return pmtf::CreateVectorFloat64(
      _fbb,
      value__);
}

struct VectorComplex64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorComplex64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorComplex64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<const pmtf::Complex64 *> *value() const {
    return GetPointer<const flatbuffers::Vector<const pmtf::Complex64 *> *>(VT_VALUE);
  }
  flatbuffers::Vector<const pmtf::Complex64 *> *mutable_value() {
    return GetPointer<flatbuffers::Vector<const pmtf::Complex64 *> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorComplex64Builder {
  typedef VectorComplex64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<const pmtf::Complex64 *>> value) {
    fbb_.AddOffset(VectorComplex64::VT_VALUE, value);
  }
  explicit VectorComplex64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorComplex64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorComplex64>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorComplex64> CreateVectorComplex64(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const pmtf::Complex64 *>> value = 0) {
  VectorComplex64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorComplex64::Traits {
  using type = VectorComplex64;
  static auto constexpr Create = CreateVectorComplex64;
};

inline flatbuffers::Offset<VectorComplex64> CreateVectorComplex64Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<pmtf::Complex64> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVectorOfStructs<pmtf::Complex64>(*value) : 0;
  return pmtf::CreateVectorComplex64(
      _fbb,
      value__);
}

struct VectorComplex128 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorComplex128Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorComplex128TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<const pmtf::Complex128 *> *value() const {
    return GetPointer<const flatbuffers::Vector<const pmtf::Complex128 *> *>(VT_VALUE);
  }
  flatbuffers::Vector<const pmtf::Complex128 *> *mutable_value() {
    return GetPointer<flatbuffers::Vector<const pmtf::Complex128 *> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorComplex128Builder {
  typedef VectorComplex128 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<const pmtf::Complex128 *>> value) {
    fbb_.AddOffset(VectorComplex128::VT_VALUE, value);
  }
  explicit VectorComplex128Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorComplex128> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorComplex128>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorComplex128> CreateVectorComplex128(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const pmtf::Complex128 *>> value = 0) {
  VectorComplex128Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorComplex128::Traits {
  using type = VectorComplex128;
  static auto constexpr Create = CreateVectorComplex128;
};

inline flatbuffers::Offset<VectorComplex128> CreateVectorComplex128Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<pmtf::Complex128> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVectorOfStructs<pmtf::Complex128>(*value) : 0;
  return pmtf::CreateVectorComplex128(
      _fbb,
      value__);
}

struct VectorInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorInt8Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorInt8TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<int8_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorInt8Builder {
  typedef VectorInt8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(VectorInt8::VT_VALUE, value);
  }
  explicit VectorInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorInt8> CreateVectorInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  VectorInt8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorInt8::Traits {
  using type = VectorInt8;
  static auto constexpr Create = CreateVectorInt8;
};

inline flatbuffers::Offset<VectorInt8> CreateVectorInt8Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return pmtf::CreateVectorInt8(
      _fbb,
      value__);
}

struct VectorInt16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorInt16Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorInt16TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int16_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<int16_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<int16_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorInt16Builder {
  typedef VectorInt16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int16_t>> value) {
    fbb_.AddOffset(VectorInt16::VT_VALUE, value);
  }
  explicit VectorInt16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorInt16>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorInt16> CreateVectorInt16(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> value = 0) {
  VectorInt16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorInt16::Traits {
  using type = VectorInt16;
  static auto constexpr Create = CreateVectorInt16;
};

inline flatbuffers::Offset<VectorInt16> CreateVectorInt16Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int16_t>(*value) : 0;
  return pmtf::CreateVectorInt16(
      _fbb,
      value__);
}

struct VectorInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorInt32Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorInt32TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<int32_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorInt32Builder {
  typedef VectorInt32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(VectorInt32::VT_VALUE, value);
  }
  explicit VectorInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorInt32> CreateVectorInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> value = 0) {
  VectorInt32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorInt32::Traits {
  using type = VectorInt32;
  static auto constexpr Create = CreateVectorInt32;
};

inline flatbuffers::Offset<VectorInt32> CreateVectorInt32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return pmtf::CreateVectorInt32(
      _fbb,
      value__);
}

struct VectorInt64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorInt64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorInt64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int64_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<int64_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorInt64Builder {
  typedef VectorInt64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int64_t>> value) {
    fbb_.AddOffset(VectorInt64::VT_VALUE, value);
  }
  explicit VectorInt64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorInt64>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorInt64> CreateVectorInt64(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> value = 0) {
  VectorInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorInt64::Traits {
  using type = VectorInt64;
  static auto constexpr Create = CreateVectorInt64;
};

inline flatbuffers::Offset<VectorInt64> CreateVectorInt64Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int64_t>(*value) : 0;
  return pmtf::CreateVectorInt64(
      _fbb,
      value__);
}

struct VectorUInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorUInt8Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorUInt8TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<uint8_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorUInt8Builder {
  typedef VectorUInt8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(VectorUInt8::VT_VALUE, value);
  }
  explicit VectorUInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorUInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorUInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorUInt8> CreateVectorUInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  VectorUInt8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorUInt8::Traits {
  using type = VectorUInt8;
  static auto constexpr Create = CreateVectorUInt8;
};

inline flatbuffers::Offset<VectorUInt8> CreateVectorUInt8Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return pmtf::CreateVectorUInt8(
      _fbb,
      value__);
}

struct VectorUInt16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorUInt16Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorUInt16TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint16_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<uint16_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<uint16_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorUInt16Builder {
  typedef VectorUInt16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> value) {
    fbb_.AddOffset(VectorUInt16::VT_VALUE, value);
  }
  explicit VectorUInt16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorUInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorUInt16>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorUInt16> CreateVectorUInt16(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> value = 0) {
  VectorUInt16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorUInt16::Traits {
  using type = VectorUInt16;
  static auto constexpr Create = CreateVectorUInt16;
};

inline flatbuffers::Offset<VectorUInt16> CreateVectorUInt16Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint16_t>(*value) : 0;
  return pmtf::CreateVectorUInt16(
      _fbb,
      value__);
}

struct VectorUInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorUInt32Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorUInt32TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<uint32_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorUInt32Builder {
  typedef VectorUInt32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value) {
    fbb_.AddOffset(VectorUInt32::VT_VALUE, value);
  }
  explicit VectorUInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorUInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorUInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorUInt32> CreateVectorUInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value = 0) {
  VectorUInt32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorUInt32::Traits {
  using type = VectorUInt32;
  static auto constexpr Create = CreateVectorUInt32;
};

inline flatbuffers::Offset<VectorUInt32> CreateVectorUInt32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint32_t>(*value) : 0;
  return pmtf::CreateVectorUInt32(
      _fbb,
      value__);
}

struct VectorUInt64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorUInt64Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorUInt64TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint64_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<uint64_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<uint64_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorUInt64Builder {
  typedef VectorUInt64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> value) {
    fbb_.AddOffset(VectorUInt64::VT_VALUE, value);
  }
  explicit VectorUInt64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorUInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorUInt64>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorUInt64> CreateVectorUInt64(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> value = 0) {
  VectorUInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorUInt64::Traits {
  using type = VectorUInt64;
  static auto constexpr Create = CreateVectorUInt64;
};

inline flatbuffers::Offset<VectorUInt64> CreateVectorUInt64Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint64_t>(*value) : 0;
  return pmtf::CreateVectorUInt64(
      _fbb,
      value__);
}

struct VectorBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorBoolBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorBoolTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<uint8_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct VectorBoolBuilder {
  typedef VectorBool Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(VectorBool::VT_VALUE, value);
  }
  explicit VectorBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorBool> CreateVectorBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  VectorBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorBool::Traits {
  using type = VectorBool;
  static auto constexpr Create = CreateVectorBool;
};

inline flatbuffers::Offset<VectorBool> CreateVectorBoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return pmtf::CreateVectorBool(
      _fbb,
      value__);
}

struct VectorPmt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorPmtBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VectorPmtTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<pmtf::Pmt>> *value() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pmtf::Pmt>> *>(VT_VALUE);
  }
  flatbuffers::Vector<flatbuffers::Offset<pmtf::Pmt>> *mutable_value() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<pmtf::Pmt>> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct VectorPmtBuilder {
  typedef VectorPmt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pmtf::Pmt>>> value) {
    fbb_.AddOffset(VectorPmt::VT_VALUE, value);
  }
  explicit VectorPmtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VectorPmt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorPmt>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorPmt> CreateVectorPmt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pmtf::Pmt>>> value = 0) {
  VectorPmtBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VectorPmt::Traits {
  using type = VectorPmt;
  static auto constexpr Create = CreateVectorPmt;
};

inline flatbuffers::Offset<VectorPmt> CreateVectorPmtDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<pmtf::Pmt>> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<flatbuffers::Offset<pmtf::Pmt>>(*value) : 0;
  return pmtf::CreateVectorPmt(
      _fbb,
      value__);
}

struct MapEntryString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapEntryStringBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapEntryStringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  flatbuffers::String *mutable_key() {
    return GetPointer<flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const MapEntryString *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  const pmtf::Pmt *value() const {
    return GetPointer<const pmtf::Pmt *>(VT_VALUE);
  }
  pmtf::Pmt *mutable_value() {
    return GetPointer<pmtf::Pmt *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct MapEntryStringBuilder {
  typedef MapEntryString Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(MapEntryString::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<pmtf::Pmt> value) {
    fbb_.AddOffset(MapEntryString::VT_VALUE, value);
  }
  explicit MapEntryStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapEntryString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapEntryString>(end);
    fbb_.Required(o, MapEntryString::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<MapEntryString> CreateMapEntryString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<pmtf::Pmt> value = 0) {
  MapEntryStringBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct MapEntryString::Traits {
  using type = MapEntryString;
  static auto constexpr Create = CreateMapEntryString;
};

inline flatbuffers::Offset<MapEntryString> CreateMapEntryStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    flatbuffers::Offset<pmtf::Pmt> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return pmtf::CreateMapEntryString(
      _fbb,
      key__,
      value);
}

struct MapString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapStringBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapStringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<pmtf::MapEntryString>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pmtf::MapEntryString>> *>(VT_ENTRIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<pmtf::MapEntryString>> *mutable_entries() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<pmtf::MapEntryString>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct MapStringBuilder {
  typedef MapString Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pmtf::MapEntryString>>> entries) {
    fbb_.AddOffset(MapString::VT_ENTRIES, entries);
  }
  explicit MapStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapString>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapString> CreateMapString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pmtf::MapEntryString>>> entries = 0) {
  MapStringBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

struct MapString::Traits {
  using type = MapString;
  static auto constexpr Create = CreateMapString;
};

inline flatbuffers::Offset<MapString> CreateMapStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<pmtf::MapEntryString>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVectorOfSortedTables<pmtf::MapEntryString>(entries) : 0;
  return pmtf::CreateMapString(
      _fbb,
      entries__);
}

struct Pmt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PmtBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PmtTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  pmtf::Data data_type() const {
    return static_cast<pmtf::Data>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const pmtf::PmtString *data_as_PmtString() const {
    return data_type() == pmtf::Data::PmtString ? static_cast<const pmtf::PmtString *>(data()) : nullptr;
  }
  const pmtf::ScalarFloat32 *data_as_ScalarFloat32() const {
    return data_type() == pmtf::Data::ScalarFloat32 ? static_cast<const pmtf::ScalarFloat32 *>(data()) : nullptr;
  }
  const pmtf::ScalarFloat64 *data_as_ScalarFloat64() const {
    return data_type() == pmtf::Data::ScalarFloat64 ? static_cast<const pmtf::ScalarFloat64 *>(data()) : nullptr;
  }
  const pmtf::ScalarComplex64 *data_as_ScalarComplex64() const {
    return data_type() == pmtf::Data::ScalarComplex64 ? static_cast<const pmtf::ScalarComplex64 *>(data()) : nullptr;
  }
  const pmtf::ScalarComplex128 *data_as_ScalarComplex128() const {
    return data_type() == pmtf::Data::ScalarComplex128 ? static_cast<const pmtf::ScalarComplex128 *>(data()) : nullptr;
  }
  const pmtf::ScalarInt8 *data_as_ScalarInt8() const {
    return data_type() == pmtf::Data::ScalarInt8 ? static_cast<const pmtf::ScalarInt8 *>(data()) : nullptr;
  }
  const pmtf::ScalarInt16 *data_as_ScalarInt16() const {
    return data_type() == pmtf::Data::ScalarInt16 ? static_cast<const pmtf::ScalarInt16 *>(data()) : nullptr;
  }
  const pmtf::ScalarInt32 *data_as_ScalarInt32() const {
    return data_type() == pmtf::Data::ScalarInt32 ? static_cast<const pmtf::ScalarInt32 *>(data()) : nullptr;
  }
  const pmtf::ScalarInt64 *data_as_ScalarInt64() const {
    return data_type() == pmtf::Data::ScalarInt64 ? static_cast<const pmtf::ScalarInt64 *>(data()) : nullptr;
  }
  const pmtf::ScalarUInt8 *data_as_ScalarUInt8() const {
    return data_type() == pmtf::Data::ScalarUInt8 ? static_cast<const pmtf::ScalarUInt8 *>(data()) : nullptr;
  }
  const pmtf::ScalarUInt16 *data_as_ScalarUInt16() const {
    return data_type() == pmtf::Data::ScalarUInt16 ? static_cast<const pmtf::ScalarUInt16 *>(data()) : nullptr;
  }
  const pmtf::ScalarUInt32 *data_as_ScalarUInt32() const {
    return data_type() == pmtf::Data::ScalarUInt32 ? static_cast<const pmtf::ScalarUInt32 *>(data()) : nullptr;
  }
  const pmtf::ScalarUInt64 *data_as_ScalarUInt64() const {
    return data_type() == pmtf::Data::ScalarUInt64 ? static_cast<const pmtf::ScalarUInt64 *>(data()) : nullptr;
  }
  const pmtf::ScalarBool *data_as_ScalarBool() const {
    return data_type() == pmtf::Data::ScalarBool ? static_cast<const pmtf::ScalarBool *>(data()) : nullptr;
  }
  const pmtf::VectorFloat32 *data_as_VectorFloat32() const {
    return data_type() == pmtf::Data::VectorFloat32 ? static_cast<const pmtf::VectorFloat32 *>(data()) : nullptr;
  }
  const pmtf::VectorFloat64 *data_as_VectorFloat64() const {
    return data_type() == pmtf::Data::VectorFloat64 ? static_cast<const pmtf::VectorFloat64 *>(data()) : nullptr;
  }
  const pmtf::VectorComplex64 *data_as_VectorComplex64() const {
    return data_type() == pmtf::Data::VectorComplex64 ? static_cast<const pmtf::VectorComplex64 *>(data()) : nullptr;
  }
  const pmtf::VectorComplex128 *data_as_VectorComplex128() const {
    return data_type() == pmtf::Data::VectorComplex128 ? static_cast<const pmtf::VectorComplex128 *>(data()) : nullptr;
  }
  const pmtf::VectorInt8 *data_as_VectorInt8() const {
    return data_type() == pmtf::Data::VectorInt8 ? static_cast<const pmtf::VectorInt8 *>(data()) : nullptr;
  }
  const pmtf::VectorInt16 *data_as_VectorInt16() const {
    return data_type() == pmtf::Data::VectorInt16 ? static_cast<const pmtf::VectorInt16 *>(data()) : nullptr;
  }
  const pmtf::VectorInt32 *data_as_VectorInt32() const {
    return data_type() == pmtf::Data::VectorInt32 ? static_cast<const pmtf::VectorInt32 *>(data()) : nullptr;
  }
  const pmtf::VectorInt64 *data_as_VectorInt64() const {
    return data_type() == pmtf::Data::VectorInt64 ? static_cast<const pmtf::VectorInt64 *>(data()) : nullptr;
  }
  const pmtf::VectorUInt8 *data_as_VectorUInt8() const {
    return data_type() == pmtf::Data::VectorUInt8 ? static_cast<const pmtf::VectorUInt8 *>(data()) : nullptr;
  }
  const pmtf::VectorUInt16 *data_as_VectorUInt16() const {
    return data_type() == pmtf::Data::VectorUInt16 ? static_cast<const pmtf::VectorUInt16 *>(data()) : nullptr;
  }
  const pmtf::VectorUInt32 *data_as_VectorUInt32() const {
    return data_type() == pmtf::Data::VectorUInt32 ? static_cast<const pmtf::VectorUInt32 *>(data()) : nullptr;
  }
  const pmtf::VectorUInt64 *data_as_VectorUInt64() const {
    return data_type() == pmtf::Data::VectorUInt64 ? static_cast<const pmtf::VectorUInt64 *>(data()) : nullptr;
  }
  const pmtf::VectorBool *data_as_VectorBool() const {
    return data_type() == pmtf::Data::VectorBool ? static_cast<const pmtf::VectorBool *>(data()) : nullptr;
  }
  const pmtf::VectorPmt *data_as_VectorPmt() const {
    return data_type() == pmtf::Data::VectorPmt ? static_cast<const pmtf::VectorPmt *>(data()) : nullptr;
  }
  const pmtf::MapString *data_as_MapString() const {
    return data_type() == pmtf::Data::MapString ? static_cast<const pmtf::MapString *>(data()) : nullptr;
  }
  void *mutable_data() {
    return GetPointer<void *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const pmtf::PmtString *Pmt::data_as<pmtf::PmtString>() const {
  return data_as_PmtString();
}

template<> inline const pmtf::ScalarFloat32 *Pmt::data_as<pmtf::ScalarFloat32>() const {
  return data_as_ScalarFloat32();
}

template<> inline const pmtf::ScalarFloat64 *Pmt::data_as<pmtf::ScalarFloat64>() const {
  return data_as_ScalarFloat64();
}

template<> inline const pmtf::ScalarComplex64 *Pmt::data_as<pmtf::ScalarComplex64>() const {
  return data_as_ScalarComplex64();
}

template<> inline const pmtf::ScalarComplex128 *Pmt::data_as<pmtf::ScalarComplex128>() const {
  return data_as_ScalarComplex128();
}

template<> inline const pmtf::ScalarInt8 *Pmt::data_as<pmtf::ScalarInt8>() const {
  return data_as_ScalarInt8();
}

template<> inline const pmtf::ScalarInt16 *Pmt::data_as<pmtf::ScalarInt16>() const {
  return data_as_ScalarInt16();
}

template<> inline const pmtf::ScalarInt32 *Pmt::data_as<pmtf::ScalarInt32>() const {
  return data_as_ScalarInt32();
}

template<> inline const pmtf::ScalarInt64 *Pmt::data_as<pmtf::ScalarInt64>() const {
  return data_as_ScalarInt64();
}

template<> inline const pmtf::ScalarUInt8 *Pmt::data_as<pmtf::ScalarUInt8>() const {
  return data_as_ScalarUInt8();
}

template<> inline const pmtf::ScalarUInt16 *Pmt::data_as<pmtf::ScalarUInt16>() const {
  return data_as_ScalarUInt16();
}

template<> inline const pmtf::ScalarUInt32 *Pmt::data_as<pmtf::ScalarUInt32>() const {
  return data_as_ScalarUInt32();
}

template<> inline const pmtf::ScalarUInt64 *Pmt::data_as<pmtf::ScalarUInt64>() const {
  return data_as_ScalarUInt64();
}

template<> inline const pmtf::ScalarBool *Pmt::data_as<pmtf::ScalarBool>() const {
  return data_as_ScalarBool();
}

template<> inline const pmtf::VectorFloat32 *Pmt::data_as<pmtf::VectorFloat32>() const {
  return data_as_VectorFloat32();
}

template<> inline const pmtf::VectorFloat64 *Pmt::data_as<pmtf::VectorFloat64>() const {
  return data_as_VectorFloat64();
}

template<> inline const pmtf::VectorComplex64 *Pmt::data_as<pmtf::VectorComplex64>() const {
  return data_as_VectorComplex64();
}

template<> inline const pmtf::VectorComplex128 *Pmt::data_as<pmtf::VectorComplex128>() const {
  return data_as_VectorComplex128();
}

template<> inline const pmtf::VectorInt8 *Pmt::data_as<pmtf::VectorInt8>() const {
  return data_as_VectorInt8();
}

template<> inline const pmtf::VectorInt16 *Pmt::data_as<pmtf::VectorInt16>() const {
  return data_as_VectorInt16();
}

template<> inline const pmtf::VectorInt32 *Pmt::data_as<pmtf::VectorInt32>() const {
  return data_as_VectorInt32();
}

template<> inline const pmtf::VectorInt64 *Pmt::data_as<pmtf::VectorInt64>() const {
  return data_as_VectorInt64();
}

template<> inline const pmtf::VectorUInt8 *Pmt::data_as<pmtf::VectorUInt8>() const {
  return data_as_VectorUInt8();
}

template<> inline const pmtf::VectorUInt16 *Pmt::data_as<pmtf::VectorUInt16>() const {
  return data_as_VectorUInt16();
}

template<> inline const pmtf::VectorUInt32 *Pmt::data_as<pmtf::VectorUInt32>() const {
  return data_as_VectorUInt32();
}

template<> inline const pmtf::VectorUInt64 *Pmt::data_as<pmtf::VectorUInt64>() const {
  return data_as_VectorUInt64();
}

template<> inline const pmtf::VectorBool *Pmt::data_as<pmtf::VectorBool>() const {
  return data_as_VectorBool();
}

template<> inline const pmtf::VectorPmt *Pmt::data_as<pmtf::VectorPmt>() const {
  return data_as_VectorPmt();
}

template<> inline const pmtf::MapString *Pmt::data_as<pmtf::MapString>() const {
  return data_as_MapString();
}

struct PmtBuilder {
  typedef Pmt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(pmtf::Data data_type) {
    fbb_.AddElement<uint8_t>(Pmt::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Pmt::VT_DATA, data);
  }
  explicit PmtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pmt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pmt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pmt> CreatePmt(
    flatbuffers::FlatBufferBuilder &_fbb,
    pmtf::Data data_type = pmtf::Data::NONE,
    flatbuffers::Offset<void> data = 0) {
  PmtBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct Pmt::Traits {
  using type = Pmt;
  static auto constexpr Create = CreatePmt;
};

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type) {
  switch (type) {
    case Data::NONE: {
      return true;
    }
    case Data::PmtString: {
      auto ptr = reinterpret_cast<const pmtf::PmtString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarFloat32: {
      auto ptr = reinterpret_cast<const pmtf::ScalarFloat32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarFloat64: {
      auto ptr = reinterpret_cast<const pmtf::ScalarFloat64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarComplex64: {
      auto ptr = reinterpret_cast<const pmtf::ScalarComplex64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarComplex128: {
      auto ptr = reinterpret_cast<const pmtf::ScalarComplex128 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarInt8: {
      auto ptr = reinterpret_cast<const pmtf::ScalarInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarInt16: {
      auto ptr = reinterpret_cast<const pmtf::ScalarInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarInt32: {
      auto ptr = reinterpret_cast<const pmtf::ScalarInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarInt64: {
      auto ptr = reinterpret_cast<const pmtf::ScalarInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarUInt8: {
      auto ptr = reinterpret_cast<const pmtf::ScalarUInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarUInt16: {
      auto ptr = reinterpret_cast<const pmtf::ScalarUInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarUInt32: {
      auto ptr = reinterpret_cast<const pmtf::ScalarUInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarUInt64: {
      auto ptr = reinterpret_cast<const pmtf::ScalarUInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::ScalarBool: {
      auto ptr = reinterpret_cast<const pmtf::ScalarBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorFloat32: {
      auto ptr = reinterpret_cast<const pmtf::VectorFloat32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorFloat64: {
      auto ptr = reinterpret_cast<const pmtf::VectorFloat64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorComplex64: {
      auto ptr = reinterpret_cast<const pmtf::VectorComplex64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorComplex128: {
      auto ptr = reinterpret_cast<const pmtf::VectorComplex128 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorInt8: {
      auto ptr = reinterpret_cast<const pmtf::VectorInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorInt16: {
      auto ptr = reinterpret_cast<const pmtf::VectorInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorInt32: {
      auto ptr = reinterpret_cast<const pmtf::VectorInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorInt64: {
      auto ptr = reinterpret_cast<const pmtf::VectorInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorUInt8: {
      auto ptr = reinterpret_cast<const pmtf::VectorUInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorUInt16: {
      auto ptr = reinterpret_cast<const pmtf::VectorUInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorUInt32: {
      auto ptr = reinterpret_cast<const pmtf::VectorUInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorUInt64: {
      auto ptr = reinterpret_cast<const pmtf::VectorUInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorBool: {
      auto ptr = reinterpret_cast<const pmtf::VectorBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::VectorPmt: {
      auto ptr = reinterpret_cast<const pmtf::VectorPmt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data::MapString: {
      auto ptr = reinterpret_cast<const pmtf::MapString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData(
        verifier,  values->Get(i), types->GetEnum<Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *DataTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::DataTypeTypeTable
  };
  static const char * const names[] = {
    "UNKNOWN",
    "FLOAT",
    "DOUBLE",
    "CFLOAT",
    "CDOUBLE",
    "INT8",
    "INT16",
    "INT32",
    "INT64",
    "UINT8",
    "UINT16",
    "UINT32",
    "UINT64",
    "BOOL",
    "ENUM",
    "STRING",
    "PMT",
    "ANY",
    "VOID"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 19, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::PmtStringTypeTable,
    pmtf::ScalarFloat32TypeTable,
    pmtf::ScalarFloat64TypeTable,
    pmtf::ScalarComplex64TypeTable,
    pmtf::ScalarComplex128TypeTable,
    pmtf::ScalarInt8TypeTable,
    pmtf::ScalarInt16TypeTable,
    pmtf::ScalarInt32TypeTable,
    pmtf::ScalarInt64TypeTable,
    pmtf::ScalarUInt8TypeTable,
    pmtf::ScalarUInt16TypeTable,
    pmtf::ScalarUInt32TypeTable,
    pmtf::ScalarUInt64TypeTable,
    pmtf::ScalarBoolTypeTable,
    pmtf::VectorFloat32TypeTable,
    pmtf::VectorFloat64TypeTable,
    pmtf::VectorComplex64TypeTable,
    pmtf::VectorComplex128TypeTable,
    pmtf::VectorInt8TypeTable,
    pmtf::VectorInt16TypeTable,
    pmtf::VectorInt32TypeTable,
    pmtf::VectorInt64TypeTable,
    pmtf::VectorUInt8TypeTable,
    pmtf::VectorUInt16TypeTable,
    pmtf::VectorUInt32TypeTable,
    pmtf::VectorUInt64TypeTable,
    pmtf::VectorBoolTypeTable,
    pmtf::VectorPmtTypeTable,
    pmtf::MapStringTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "PmtString",
    "ScalarFloat32",
    "ScalarFloat64",
    "ScalarComplex64",
    "ScalarComplex128",
    "ScalarInt8",
    "ScalarInt16",
    "ScalarInt32",
    "ScalarInt64",
    "ScalarUInt8",
    "ScalarUInt16",
    "ScalarUInt32",
    "ScalarUInt64",
    "ScalarBool",
    "VectorFloat32",
    "VectorFloat64",
    "VectorComplex64",
    "VectorComplex128",
    "VectorInt8",
    "VectorInt16",
    "VectorInt32",
    "VectorInt64",
    "VectorUInt8",
    "VectorUInt16",
    "VectorUInt32",
    "VectorUInt64",
    "VectorBool",
    "VectorPmt",
    "MapString"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 30, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Complex64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "re",
    "im"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Complex128TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16 };
  static const char * const names[] = {
    "re",
    "im"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PmtStringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarFloat32TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarFloat64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarComplex64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::Complex64TypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarComplex128TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::Complex128TypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarInt8TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarInt16TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarInt32TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarInt64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarUInt8TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarUInt16TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarUInt32TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarUInt64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScalarBoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorFloat32TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorFloat64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorComplex64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::Complex64TypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorComplex128TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::Complex128TypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorInt8TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorInt16TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorInt32TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorInt64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorUInt8TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorUInt16TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorUInt32TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorUInt64TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorBoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VectorPmtTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::PmtTypeTable
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapEntryStringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::PmtTypeTable
  };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapStringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::MapEntryStringTypeTable
  };
  static const char * const names[] = {
    "entries"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PmtTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    pmtf::DataTypeTable
  };
  static const char * const names[] = {
    "data_type",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const pmtf::Pmt *GetPmt(const void *buf) {
  return flatbuffers::GetRoot<pmtf::Pmt>(buf);
}

inline const pmtf::Pmt *GetSizePrefixedPmt(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<pmtf::Pmt>(buf);
}

inline Pmt *GetMutablePmt(void *buf) {
  return flatbuffers::GetMutableRoot<Pmt>(buf);
}

inline bool VerifyPmtBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<pmtf::Pmt>(nullptr);
}

inline bool VerifySizePrefixedPmtBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<pmtf::Pmt>(nullptr);
}

inline void FinishPmtBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<pmtf::Pmt> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPmtBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<pmtf::Pmt> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace pmtf

#endif  // FLATBUFFERS_GENERATED_PMT_PMTF_H_
